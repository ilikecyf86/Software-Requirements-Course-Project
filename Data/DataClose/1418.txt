CLI Evolution
kind/enhancement 
We are starting to see the Docker-ized CLI stablize quickly. We are seeing few reports of issues related to CLI bugs. New user issues are almost related to networking configuration, permissions on the file system, or misusing the CLI (mistyped parameters, bad volume mounts, etc). We have an opportunity to further simplify how users interact with Che using the CLI. It strikes us that the CLI forces users to provide a variety of mandatory (and sometimes optional) parameters repetiively. The values of these parameters rarely change, such as the location of :/data or :/repo. Or, in many cases, the values of parameters can be automatically identified based upon the context of the user, such as a user who wants to SSH into a workspace that they are viewing in the dashboard (we know the Che server, the workspace id, and optionally certain SSH keys). Additionally, the CLI today has functions for both administrators and end users, and these functions should not always be combined together. End users require a smaller subset of commands in the CLI. For example, an end user should not be able to start or stop Che, but they are allowed to use the SSH command to connect to a workspace. We propose to evolve the CLI in a few ways to address these problems. Build a native binary for each OS that can run Che with the simple syntax of che. This native binary CLI would contain the logic for executing docker run -it --rm ...". Users of this binary would be able to use the CLI by running something similar toche start --fast, which would have been the equivalent ofdocker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock -v $(pwd):/data eclipse/che: start --fast. The location of the:/datafolder would be the current directory and theof the image to use can be extracted by looking at the version of the current initialized folder. This would assume that the binary is located in the:/datafolder and that the:/data` folder has already been initialized by the CLI. Admins would always be required for their first initialization to use the docker run ... syntax. We would place the native binary of the CLI in the Docker image and the right binary for the host would be placed into the :/data folder during the initialization method. This would require the native CLI binaries to be built by CI and then packaged within the right image. These admin binaries would have the capability to execute all of the commands available in the CLI. In the user dashboard, we could allow end users to download a user CLI binary to their hard drive. They would then add this to their PATH appropriately. This CLI binary would only allow for end users to execute CLI commands like ssh, sync, which are items related to an end user's interaction with the system. In this situation, the CLI binary may not be installed into the same folder as :/data. And, the binaries could be installed on a remote machine. So the location of the Che server and the details needed to execute the docker run ... command would need to be packaged with the CLI somehow. It could be a file saved in .che next to the binary (not clean) or it could be some sort of way to inject the statefulness into the binary before it is downloaded onto the end user's computer. This could eventually be extended to context-sensitivity in the user dashboard. We could offer CLI links when viewing workspaces in the user dashboard. A user could CLI SSH into a specific workspace by clicking this link next to the workspace, and the CLI would be activated on the end user's laptop with a configuration parameters that further removed the need for the end user to type syntax to identify the workspace name when doing SSH.