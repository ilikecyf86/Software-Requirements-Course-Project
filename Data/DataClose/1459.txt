Replace previous implementation of file watchers that used for search index (based on inotify) with scheduled treeWalker
kind/enhancement team/ide sprint/current-sprint 
According to current logic, it recursively register an observer for every directory including projectsâ€™ root directory ('/projects' by default) so eventually we have as many file watchers as many directories we have under '/projects' location. Java libraries that are used for those operations are built on Linux kernel subsystem called inotify. The mentioned subsystem has it's default limits of inotify watchers around 128k which means that we can track no more than 128k of directories. This number is distributed among all kernel users and according to existing reports the limit is being exceeded quite often. This leads to malfunction of the file watching subsystem and in rare cases even to inability to start workspace. Previously the attempt to overcome those impediments was made. The result of those efforts is the new dynamic file watching system which excels in ability to flexibly manage resources (frees inotify limit) However this approach has its limitations. In order to dynamically watch and unwatch directories/files, we have to know exactly what to observe (location, name, etc.) in addition it is designed to accurately track moderate amount (comparing to the project size) of file system items. Obviously if we track all directories in a project we will have the same resource problem that we had with previous implementation. It would be okay if there were no real requirements to track the whole project folder state (e.g. to track pom.xml files). So what we can do here is to make a hybrid file watching system. We will have dynamic file watchers that will provide near real time responses (less than a second) to track file system items in a short range and along with that we will also have static file watchers system that will have a moderate response time (several seconds) to track the whole file tree under root project directory. Words dynamic and static are used in a context of resource management. It seems to be a good idea (taking into account the ratio of complexity and effectivity) to use JDK file tree walking facilities to periodically and recursively update in-memory project structures as an initial implementation. Though the free walk frequency and performance of such approach may be a topic of a separate discussion (along with alternatives), according to preliminary analysis this approach should fit our requirements quite well.