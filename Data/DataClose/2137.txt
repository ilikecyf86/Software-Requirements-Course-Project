Cascade deletion of projects with the same storage fails
kind/bug status/analyzing team/platform sprint/next-sprint sprint/current-sprint status/open-for-dev sprint/next-sprint status/analyzing status/in-progress status/open-for-dev status/code-review status/in-progress sprint/current-sprint status/code-review 
If remove user who has more than one workspace with projects that have the same source storage, removal transaction will fail. Check out the commit in branch removal_test which adds breaking use-case. The problem is that eclipselink collects removal dependecies information in hash map where key is removal object and value is a hash set of removal object dependencies. SourceStorage equals and hashCode don't include synthetic id field which is present in object itself and makes 2 source storage different, so in this case eclipselink sees 2 different source storages as one object(because the other object fields are the same) and builds dependency graph like source -> [project1, project2], but sometimes it happens that project1 is already removed and no longer a part of this unit of work which causes the problem. Trace from test: org.eclipse.che.api.core.ServerException: Exception [EclipseLink-6004] (Eclipse Persistence Services - 2.6.2.v20151217-774c696): org.eclipse.persistence.exceptions.QueryException
Exception Description: The object [ProjectConfigImpl{name='workspace1-project2', path='/workspace1-project2', description='workspace1-project2-description', type='workspace1-project2type', mixins=[mixin1, mixin2], attributes={attribute1=[value1], attribute3=[value3], attribute2=[value2]}, source=SourceStorageImpl{type='source-type', location='source-location', parameters={param2=value, param1=value}}}], of class [class org.eclipse.che.api.workspace.server.model.impl.ProjectConfigImpl], with identity hashcode (System.identityHashCode()) [945,150,386], 
is not from this UnitOfWork object space, but the parent session's.  The object was never registered in this UnitOfWork, 
but read from the parent session and related to an object registered in the UnitOfWork.  Ensure that you are correctly
registering your objects.  If you are still having problems, you can use the UnitOfWork.validateObjectSpace() method to 
help debug where the error occurred.  For more information, see the manual or FAQ.
 Putting @Cachable(false) on those objects which contain synthetic identifiers, the test will not throw that exception, but it still requires investigation.