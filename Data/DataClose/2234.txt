Performance issues with code completion
kind/enhancement sprint/next-sprint team/ide sprint/next-sprint team/ide sprint/next-sprint team/ide sprint/current-sprint sprint/current-sprint sprint/next-sprint 
The issue from user point of view is that sometimes there is a big delay (5-10 seconds) between invoking code completion and showing the list with proposals. An acceptable delay would be less than a seconds, and if close to a second, not to have the delay on every keystroke. After spending some time examining how code completion works both in VS Code and Eclipse Che, I can say that the performance issue in Che is not observed in VS Code using the same language server. So, we should look for optimizing the code completion mechanism on Che side rather than in the specific language servers. Issue 1. Che floods the DOM tree with HTML elements for each completion proposal item. It's a common case the language server to return a completion list with 5,000-10,000 items and even more. Currently, Che adds a <li> element to the completion proposal widget for each proposal item. And each <li> element includes several <span> elements for coloring. This flood to the DOM tree is the major contributor to the big delay. Instead of this wasteful generation of thousands of HTML elements, the completion proposal widget should have a fixed number of <li> elements that cover the visible area plus some buffer above and below it. These <li> elements should be reused as the user scrolls the list up and down. I am not sure at the moment how this can be achieved with GWT, my knowledge is still pretty limited. As a low hanging fruit, we can just limit the maximum number of items displayed in the completion proposal widget to some reasonable number (e.g. 300). Issue 2. Che does not respect the CompletionList.isIncomplete flag. This flag tells the client if further typing would return different result. If the flag is false, i.e. the list is "complete" then the client should not send another completion request to the server, but just do additional filtering on the result from the previous request. Respecting the isIncomplete flag would avoid sending unnecessary completion requests on every key stroke. Issue 1 is the more severe one and affects not only the code completion with language servers, but also the code completion in general, e.g. it affects the Java code completion.